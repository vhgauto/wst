---
title: "<titulo>Water Surface Temperature</titulo>"
author:
  - name: Víctor Gauto
    orcid: 0000-0001-9960-8558
    corresponding: true
    email: victor.gauto@ca.frre.utn.edu.ar
    affiliations:
      - name: GISTAQ (UTN-FRRe)
        url: https://www.instagram.com/gistaq.utn/
      - name: IIDTHH (UNNE, CONICET)
        url: https://iidthh.conicet.gov.ar/
      - name: Instituto Gulich (UNC, CONAE)
        url: https://ig.conae.unc.edu.ar/
  - name: Matías Bonansea
    orcid: 0000-0003-1953-2595
    affiliations:
      - name: ICBIA
        url: https://icbia.conicet.gov.ar/      
format: 
  html:
    number-sections: true
    embed-resources: true
    link-external-newwindow: true
    html-math-method: katex
    highlight-style: kate
    theme:
      - extra/mis_estilos.scss
    code-fold: show
    toc: true
    toc-title: Contenido
    lang: es
    language: 
      es:
        title-block-author-single: "Autor"
        title-block-author-plural: "Autores"
date: last-modified
editor_options: 
  chunk_output_type: console
execute: 
  warning: false
---

```{r}
#| echo: false
#| warning: false

library(terra)
library(gt)
library(tidyterra)
library(tidyverse)

gain_b10 <- 0.0003342
bias_b10 <- .1

gain_b11 <- 0.0003342
bias_b11 <- .1

k1_b10 <- 774.8853
k2_b10 <- 1321.0789

k1_b11 <- 480.8883
k2_b11 <- 1201.1442

e_b10 <- 0.992
e_b11 <- 0.998
e_prom <- 0.995
e_delta <- -0.006

b0 <- 2.29250
b1 <- 0.99290
b2 <- 0.15450
b3 <- -0.31220
b4 <- 3.71860
b5 <- 0.35020
b6 <- -3.58890
b7 <- 0.18250

l <- list.files(
  path = "Matias_2025/",
  pattern = ".tif$",
  full.names = TRUE
)
```

## Datos

Se utilizó la plataforma [Google Earth Engine](https://earthengine.google.com/) para la descarga sistemática de los productos satelitales.

El producto utilizado fue [USGS Landsat 8 Collection 2 Tier 1 Raw Scenes](https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LC08_C02_T1), con valores de píxel en número digital ($DN$).

[Un producto de similares características es el [USGS Landsat 8 Collection 2 Tier 1 TOA Reflectance](https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LC08_C02_T1_TOA), en el que las bandas térmicas se encuentran en $K$.]{.aside}

El rango temporal del [script](https://code.earthengine.google.com/320273fe447374926069563f0a5db7bb?noload=true) es entre 2013 y 2025, tomando únicamente el mosaico correspondiente a la fila 82 ($WRS\_ROW=82$). Se utilizó un vector alrededor del Embalse Río Tercero para recortar el producto y conservar únicamente la porción de interés. En total se descargaron <u>**`{r} length(l)`**</u> recortes.

## Cálculo de $wst$

Inicialmente se calcula la radiancia espectral para la banda $k$:

$$
L_{sensor, k}=gain_k \cdot DN+bias_k
$$

Para las bandas B10 y B11 de **Landsat 8**, $gain$ y $bias$ son:

```{r 1}
#| echo: false

tibble(
  Banda = c("B10", "B11"),
  Gain = c(0.0003342, 0.0003342),
  Bias = c(.1, .1)
) |>
  gt()
```

El cálculo de temperatura ($K$), para las bandas B10 y B11, utiliza la siguiente expresión:

$$
T=\frac{K_2}{ln(\frac{K_1}{L_{sensor}}+1)}
$$

Siendo las constantes $K_1$ y $K_2$:

```{r 2}
#| echo: false

tibble(
  Banda = c("B10", "B11"),
  k1 = c(774.8853, 480.8883),
  k2 = c(1321.0789, 1201.1442)
) |>
  gt() |>
  cols_label(
    k1 ~ md("K<sub>1</sub>"),
    k2 ~ md("K<sub>2</sub>")
  )
```

La temperatura superficial del agua ($wst$) en $K$ se obtiene a partir de la siguiente ecuación:

$$
wst=b_0+\left( b_1+b_2\frac{1-\bar{\epsilon}}{\bar{\epsilon}}+b_3\frac{\Delta \bar{\epsilon}}{\bar{\epsilon}^2} \right)\frac{T_{B10}+T_{B11}}{2} + \left( b_4+b_5\frac{1-\bar{\epsilon}}{\bar{\epsilon}}+b_6\frac{\Delta \bar{\epsilon}}{\bar{\epsilon}^2} \right)\frac{T_{B10}-T_{B11}}{2}+b_7(T_{B10}-T_{B11})^2
$$

Los coeficiente $b$ son:

[A. Gerace, T. Kleynhans, R. Eon, and M. Montanaro, “Towards an Operational, Split Window-Derived Surface Temperature Product for the Thermal Infrared Sensors Onboard Landsat 8 and 9,” Remote Sensing, vol. 12, no. 2, p. 224, Jan. 2020, doi: <https://doi.org/10.3390/rs12020224>.]{.aside}

```{r 3}
#| echo: false

tibble(
  cte = paste0("$b_{", 0:7, "}$"),
  v = c(
    2.29250,
    0.99290,
    0.15450,
    -0.31220,
    3.71860,
    0.35020,
    -3.58890,
    0.18250
  )
) |>
  gt() |>
  fmt_markdown(columns = everything()) |>
  tab_options(column_labels.hidden = TRUE)
```

Las emisividades $\epsilon$ son:

```{r 4}
#| echo: false

tibble(
  cte = c(
    "$\\epsilon_{B10}$",
    "$\\epsilon_{B11}$",
    "$\\bar{\\epsilon}$",
    "$\\Delta \\epsilon$"
  ),
  v = c(0.992, 0.998, 0.995, -0.006)
) |>
  gt() |>
  fmt_markdown(columns = cte) |>
  tab_options(column_labels.hidden = TRUE)
```

Siendo:

$$
\bar{\epsilon}=\frac{\epsilon_{B10}+\epsilon_{B11}}{2}
$$
$$
\Delta \bar{\epsilon} = \epsilon_{B10}-\epsilon_{B11}
$$

## Procesamiento

Se leen todos los archivos ráster e identifico los píxeles de interés mediante la banda de calidad ($QA\_PIXEL$).

```{r 5}
l <- list.files(
  path = "Matias_2025_RGB/",
  pattern = ".tif$",
  full.names = TRUE
)

r <- map(l, rast)

f_mask <- function(x) {
  m <- ifel(x$QA_PIXEL == 21952, 1, NA)
  if (is.na(terra::global(m, na.rm = TRUE)$mean)) {
    r <- NULL
  } else {
    r <- x * m
  }
  return(r)
}

r_mask <- map(r, f_mask, .progress = TRUE)
```

[En [Landsat 8-9 Collection 2 (C2) Level 2 Science Product (L2SP) Guide](https://d9-wret.s3.us-west-2.amazonaws.com/assets/palladium/production/s3fs-public/media/files/LSDS-1619_Landsat8-9-Collection2-Level2-Science-Product-Guide-v6.pdf), sección 6.1.1, se muestra una descripción detallada del significado de la asignación de bits.]{.aside}

El número entero a verificar en $QA\_PIXEL$ es $21952$, que corresponde con $`{r} R.utils::intToBin(21824)`$. De acuerdo con la [documentación](https://www.usgs.gov/landsat-missions/landsat-collection-2-quality-assessment-bands) de Landsat, representa la ausencia de nubes y sus sombras, con cielo despejado y superficie de agua.

Descarto todos los productos que estén totalmente cubiertos de nubes.

```{r 6}
r_agua <- tibble(
  x = r_mask
) |>
  mutate(raster = map_lgl(x, is.null)) |>
  filter(!raster) |>
  pull(x)
```

Quedando <u>**`{r} length(r_agua)`**</u> productos libres de nubosidad total. Puedo verificar las imágenes descartadas.

```{r 7}
#| eval: false
#| code-fold: true

nubes <- tibble(
  x = r_mask
) |>
  mutate(nro = row_number()) |>
  mutate(raster = map_lgl(x, is.null)) |>
  filter(raster) |>
  pull(nro)

png(
  width = 30,
  height = 30 * 481 / 524,
  units = "cm",
  res = 300,
  bg = "transparent",
  filename = "fig/nubes.png"
)

par(mfcol = c(3, 3), mar = c(1, 1, 0, 0))

walk(
  nubes[1:9],
  ~ terra::plotRGB(
    r[[.x]],
    r = 3,
    g = 2,
    b = 1,
    smooth = FALSE,
    stretch = "lin",
    mar = c(1, 1, 1, 1)
  )
)

dev.off()
```

::: {.callout-note collapse=true icon=false}

## Imágenes completamenete cubiertas de nubes

![](fig/nubes.png)

:::

Quedan algunos productos con presencia parcial de nubes. A partir del área total del Embalse (~45km$^2$), se conservan únicamente aquellas fechas con al menos 70% del área total sin nubes.

```{r 8}
#| eval: false
#| code-fold: true
#| echo: false

f_area <- function(x) {
  print(varnames(x))
  tibble(
    area = expanse(x$QA_PIXEL)$area,
    fecha = str_sub(varnames(x), 13, 20) |> ymd()
  )
}

area_embalse <- map(r_agua, f_area) |>
  list_rbind()

write_csv(wst_area, "datos/area_embalse.csv")
```

```{r 9}
#| eval: false
#| code-fold: true

area_embalse <- read_csv("datos/area_embalse.csv", show_col_types = FALSE)
max_area <- max(area_embalse$area)

fechas_nubes_parciales <- area_embalse |>
  slice_min(order_by = area, n = 9) |>
  pull(fecha)

no_areas <- tibble(
  x = r
) |>
  mutate(nro = row_number()) |>
  mutate(
    fecha = map_chr(x, varnames)
  ) |>
  mutate(
    fecha = ymd(str_sub(fecha, -8))
  ) |>
  filter(fecha %in% fechas_nubes_parciales) |>
  pull(nro)

png(
  width = 30,
  height = 30 * 481 / 524,
  units = "cm",
  res = 300,
  bg = "transparent",
  filename = "fig/nubes_parcial.png"
)

par(mfcol = c(3, 3), mar = c(1, 1, 0, 0))

walk(
  no_areas[1:9],
  ~ terra::plotRGB(
    r[[.x]],
    r = 3,
    g = 2,
    b = 1,
    smooth = FALSE,
    stretch = "lin",
    mar = c(1, 1, 1, 1)
  )
)

dev.off()
```

::: {.callout-note collapse=true icon=false}

## Imágenes parcialmente cubiertas de nubes

![](fig/nubes_parcial.png)

:::

```{r 10}
area_embalse <- read_csv("datos/area_embalse.csv", show_col_types = FALSE)
max_area <- max(area_embalse$area)

areas <- area_embalse |>
  mutate(nro = row_number()) |>
  filter(area >= max_area * .7) |>
  pull(nro)

r_clean <- tibble(
  x = r_agua
) |>
  mutate(nro = row_number()) |>
  filter(nro %in% areas) |>
  pull(x)
```

Por lo tanto se conservan <u>**`{r} length(r_clean)`**</u> productos.

Luego calculo las radiancias espectrales `l_10` y `l_11`.

```{r 11}
f_radiancia_10 <- function(x) {
  x$B10 * gain_b10 + bias_b10
}

f_radiancia_11 <- function(x) {
  x$B11 * gain_b11 + bias_b11
}

r_l_10 <- map(r_clean, f_radiancia_10)
r_l_11 <- map(r_clean, f_radiancia_11)
```

A partir de las radiancias se obtienen las temperaturas por cada banda, `t_10` y `t_11`.

```{r 12}
f_t_10 <- function(x) {
  k2_b10 / (log(k1_b10 / x + 1))
}

f_t_11 <- function(x) {
  k2_b11 / (log(k1_b11 / x + 1))
}

r_t_10 <- map(r_l_10, f_t_10)
r_t_11 <- map(r_l_11, f_t_11)
```

Finalmente, calculo la temperatura superficial $wst$.

```{r 13}
f_wst <- function(t10, t11) {
  term1 <- b1 + b2 * ((1 - e_prom) / (e_prom)) + b3 * ((e_delta) / (e_prom^2))
  term2 <- b4 + b5 * ((1 - e_prom) / (e_prom)) + b6 * ((e_delta) / (e_prom^2))

  b0 + term1 * (t10 + t11) / 2 + term2 * (t10 - t11) / 2 + b7 * (t10 - t11)^2
}

wst <- map2(r_t_10, r_t_11, ~ f_wst(.x, .y))
```

Se calculan $wst$ promedio en todo el Embalse para todas las fechas disponibles.

```{r 14}
f_promedio <- function(x) {
  tibble(
    temp = terra::global(x, fun = "mean", na.rm = TRUE)$mean,
    fecha = str_sub(varnames(x), 13, 20) |> ymd()
  )
}

wst_prom <- map(wst, f_promedio) |>
  list_rbind()
```

Almaceno los valores promedios de temperatura.

```{r 15}
write_csv(wst_prom, "datos/wst_prom.csv")
wst_prom <- read_csv("datos/wst_prom.csv", show_col_types = FALSE)
```

## Serie temporal de $wst$

Datos disponibles por año.

```{r 16}
#| code-fold: true

map_chr(wst, ~ (str_sub(varnames(.x), 13, 20))) |>
  ymd() |>
  tibble(fecha = _) |>
  mutate(año = year(fecha)) |>
  count(año) |>
  gt() |>
  cols_label(
    año = "Año",
    n = "#"
  )
```

La serie temporal de las temperaturas, en $°C$.

```{r 17}
#| code-fold: true

g1 <- ggplot(wst_prom, aes(fecha, temp - 273.15)) +
  geom_line(linewidth = .3, color = "grey40") +
  geom_point(
    size = 1,
    shape = 21,
    color = "grey40",
    fill = "violetred",
    alpha = 1,
    stroke = .1
  ) +
  geom_smooth(aes(color = "a"), se = FALSE, formula = y ~ x, method = "loess") +
  scale_x_date(
    date_breaks = "1 year",
    date_labels = "%Y"
  ) +
  scale_y_continuous(
    breaks = scales::breaks_width(2),
    limits = c(9, 31),
    expand = c(0, 0)
  ) +
  scale_color_manual(
    values = "violetred",
    labels = "Tendencia",
    name = NULL
  ) +
  labs(x = NULL, y = "wst (°C)") +
  theme_classic() +
  theme(
    text = element_text(color = "black"),
    plot.background = element_blank(),
    panel.grid.major = element_line(),
    panel.background = element_blank(),
    axis.ticks = element_blank(),
    axis.text = element_text(color = "black"),
    legend.background = element_rect(
      color = "black",
      linewidth = .3,
      fill = "#FAFAFA"
    ),
    legend.margin = margin(2, 2, 2, 2),
    legend.position = "inside",
    legend.key = element_blank(),
    legend.position.inside = c(1, 1),
    legend.justification.inside = c(1, 1)
  )

ggsave(
  plot = g1,
  filename = "fig/wst_serie_temporal.png",
  width = 20,
  height = 10,
  units = "cm"
)
```

::: {.column-page-inset}

![](fig/wst_serie_temporal.png)

:::

Calculando las medias por año.

```{r 18}
#| code-fold: true
#| column: page

g2 <- wst_prom |>
  mutate(año = year(fecha)) |>
  mutate(año = factor(año)) |>
  ggplot(aes(año, temp - 273)) +
  geom_point(
    position = position_jitter(seed = 2025, width = .2),
    alpha = .25,
    size = 1
  ) +
  stat_summary(
    fun = "mean",
    aes(fill = "a"),
    size = .6,
    key_glyph = "point",
    shape = 21,
    stroke = .6,
    color = "grey"
  ) +
  scale_y_continuous(
    breaks = scales::breaks_width(2),
    limits = c(9, 31),
    expand = c(0, 0)
  ) +
  scale_fill_manual(
    values = "violetred",
    labels = "Promedio\nanual",
    name = NULL
  ) +
  labs(x = NULL, y = "wst (°C)") +
  guides(fill = guide_legend(override.aes = list(size = 3))) +
  theme_classic() +
  theme(
    text = element_text(color = "black"),
    plot.background = element_blank(),
    panel.background = element_blank(),
    panel.grid.major = element_line(),
    axis.ticks = element_blank(),
    axis.text = element_text(color = "black"),
    legend.position = "inside",
    legend.background = element_rect(
      color = "black",
      linewidth = .3,
      fill = "#FAFAFA"
    ),
    legend.margin = margin(2, 2, 2, 2),
    legend.key = element_blank(),
    legend.position.inside = c(1, 1),
    legend.justification.inside = c(1, 1)
  )

ggsave(
  plot = g2,
  filename = "fig/wst_media_anual.png",
  width = 20,
  height = 10,
  units = "cm"
)
```

::: {.column-page-inset}

![](fig/wst_media_anual.png)

:::

## Mapas

Visualizo un mapa de $wst$ por año.

```{r 19}
#| eval: false
#| code-fold: true

wst_año <- tibble(
  x = wst
) |>
  mutate(fecha = map_chr(x, ~ str_sub(varnames(.x), 13, 20))) |>
  mutate(fecha = ymd(fecha)) |>
  mutate(año = year(fecha)) |>
  slice_head(n = 1, by = año) |>
  pull(x)

f_mapa <- function(r) {
  titulo <- ymd(str_sub(varnames(r), 13, 20))

  ggplot() +
    geom_spatraster(
      data = r - 273.15
    ) +
    scale_fill_whitebox_c(
      palette = "muted",
      name = "wst (°C)",
      limits = c(16, 38),
      breaks = seq(16, 38, 2)
    ) +
    coord_sf(expand = FALSE) +
    labs(title = titulo) +
    theme_void() +
    theme(
      plot.title = element_text(hjust = .5, face = "bold", size = 8),
    )
}

wst_mapa <- map(wst_año, f_mapa)

wst_mapa_comp <- patchwork::wrap_plots(wst_mapa, nrow = 3, guides = "collect") &
  theme(
    plot.background = element_blank(),
    legend.position = "bottom",
    legend.title = element_text(margin = margin(b = 10, r = 5)),
    legend.key.height = unit(5, "pt"),
    legend.key.width = unit(45, "pt")
  )

ggsave(
  plot = wst_mapa_comp,
  filename = "fig/wst_mapa_comp.png",
  width = 30,
  height = 30 * 3 / 5 + 2,
  units = "cm"
)
```

::: {.column-screen-inset}

![](fig/wst_mapa_comp.png)

:::

## Verificación de nubes {.unnumbered}

```{r 20}
#| eval: false
#| code-fold: true

f_fecha <- function(x) {
  varnames(x) |>
    str_sub(-8) |>
    ymd()
}

f_rgb <- function(x, carpeta) {
  tit <- f_fecha(r[[x]])

  png(
    width = 1000,
    height = round(1000 * 481 / 524),
    units = "px",
    bg = "transparent",
    filename = paste0("fig/", carpeta, "/", tit, ".png")
  )

  terra::plotRGB(
    r[[x]],
    r = 3,
    g = 2,
    b = 1,
    smooth = FALSE,
    stretch = "lin",
    mar = c(1, 1, 4, 1),
    main = as.character(tit),
    cex.main =
  )

  dev.off()
}

r_tbl <- tibble(
  x = r
) |>
  mutate(
    fecha = map(x, f_fecha) |> list_c()
  ) |>
  mutate(nro = row_number())
```

Nubosidad total.

```{r 21}
#| eval: false
#| code-fold: true

r_agua_tbl <- tibble(
  x_agua = r_agua
) |>
  mutate(
    fecha = map(x_agua, f_fecha) |> list_c()
  )

todas_nubes <- anti_join(r_tbl, r_agua_tbl, by = join_by(fecha)) |>
  pull(nro)

walk(todas_nubes, ~ f_rgb(.x, "nubes_png"), .progress = TRUE)

l_nubes <- list.files(
  path = "fig/nubes_png/",
  pattern = "png",
  full.names = TRUE
)

av::av_encode_video(
  input = l_nubes,
  framerate = 2,
  output = "vid/nubes.mp4"
)
```

::: {.callout-note collapse=true icon=false}

## Nubosidad total

![](vid/nubes.mp4){loop="true"}

:::

Nubosidad parcial (hasta el 30% del Embalse cubierto).

```{r 22}
#| eval: false
#| code-fold: true

r_clean_tbl <- tibble(
  x_clean = r_clean
) |>
  mutate(
    fecha = map(x_clean, f_fecha) |> list_c()
  )

todas_nubes_parciales <- anti_join(r_tbl, r_clean_tbl, by = join_by(fecha)) |>
  inner_join(r_agua_tbl, by = join_by(fecha)) |>
  pull(nro)

walk(
  todas_nubes_parciales,
  ~ f_rgb(.x, "nubes_parciales_png"),
  .progress = TRUE
)

l_nubes_parciales <- list.files(
  path = "fig/nubes_parciales_png/",
  pattern = "png",
  full.names = TRUE
)

av::av_encode_video(
  input = l_nubes_parciales,
  framerate = 2,
  output = "vid/nubes_parciales.mp4"
)

```

::: {.callout-note collapse=true icon=false}

## Nubosidad parcial

![](vid/nubes_parciales.mp4){loop="true"}

:::

Cielo despejado.

```{r 23}
#| eval: false
#| code-fold: true

r_clean_tbl <- tibble(
  x_clean = r_clean
) |>
  mutate(
    fecha = map(x_clean, f_fecha) |> list_c()
  )

todas_despejado <- inner_join(r_tbl, r_clean_tbl, by = join_by(fecha)) |>
  pull(nro)

walk(todas_despejado, ~ f_rgb(.x, "despejado_png"), .progress = TRUE)

l_despejado <- list.files(
  path = "fig/despejado_png/",
  pattern = "png",
  full.names = TRUE
)

av::av_encode_video(
  input = l_despejado,
  framerate = 2,
  output = "vid/despejado.mp4"
)
```

::: {.callout-note collapse=true icon=false}

## Despejado

![](vid/despejado.mp4){loop="true"}

:::

